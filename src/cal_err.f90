subroutine cal_error(nx0,ny0,np,nb,r0,degree)
use mod_reynolds, only : nr
use mod_sympoly, only : maxv,mons,monid
use mod_genpoly, only : norder,btotal
use mod_fi, only : nfi,fmons,fmonid,nexit
implicit none
integer,intent(in) :: np,nb,nx0,ny0,degree
real(kind=8),intent(in) :: r0(nr,maxv)
integer :: nx,ny ! number of data randomly generated
integer :: i,j,k,iloop,nfi0,i0
real(kind=8) :: matA(nx0,ny0),vecB(nx0),coefC(nx0),matAx(nx0,ny0),vecBx(nx0)
real(kind=8) :: v,error,work(2*nx0*ny0)
! matA(nx0,ny0) nx0 is the maximal dimension of samples
! matA(nx0,ny0) ny0 is the maximal number of polynomials which contain
! the polynomials generated by degree 1 ~ N-1, and the new FIs.
! calculate nb samples for the nfi FIs.
! matA(1:nb,1:nfi)
nfi0=nfi
nx=nb+100
ny=nb
do i=1,nx
  do j=1,nfi0
    k=fmonid(j)-1
    call poly_value(fmonid(j),fmons(1,1:k,j),fmons(2,1:k,j),r0(1:nr,i),matA(i,j))
  enddo
enddo
! add the value of polynomials generated by
! the previous FIs
! matA(1:nb,nfi+1,nfi+nb)
do i=1,nb
  matA(1:nx,nfi0+i)=1.d0
  do j=1,btotal(0,i)
    matA(1:nx,nfi0+i)=matA(1:nx,nfi0+i)*matA(1:nx,btotal(j,i))
  enddo
enddo
! test whether the new polynomials in degree N is a FI,
! if it is a FI, add it to matA
do iloop=1,np
  do i=1,nx
    k=monid(iloop)-1
    call poly_value(monid(iloop),mons(1,1:k,iloop),mons(2,1:k,iloop),r0(1:nr,i),vecB(i))
  enddo
  matAx(1:nx,1:ny)=matA(1:nx,nfi0+1:nfi0+ny)
  vecBx(1:nx)=vecB(1:nx)
  call lsq(nx,ny,nx0,ny0,matAx,vecBx,coefC,work)
  error=0.d0
  do i=1,nx
    v=0.d0
    do j=1,ny
      v=v+coefC(j)*matA(i,nfi0+j)
    enddo
    error=error+((v-vecB(i)))**2
  enddo
  error=(error/real(nx))**(1.d0/2.d0)
  if(error.gt.1.d0) then
    nfi=nfi+1
    fmons(:,:,nfi)=mons(:,:,iloop)
    fmonid(nfi)=monid(iloop)
    norder(degree)=norder(degree)+1
    call write_poly(fmonid(nfi),fmons(1,1:fmonid(nfi)-1,nfi),fmons(2,1:fmonid(nfi)-1,nfi),nfi)
    !-------------------
    ny=ny+1
    matA(1:nx,nfi0+ny)=vecB(1:nx)
    do i0=1,1
      nx=nx+1
      do j=1,nfi0
        k=fmonid(j)-1
        call poly_value(fmonid(j),fmons(1,1:k,j),fmons(2,1:k,j),r0(1:nr,nx),matA(nx,j))
      enddo
      do i=1,nb
        matA(nx,nfi0+i)=1.d0
        do j=1,btotal(0,i)
          matA(nx,nfi0+i)=matA(nx,nfi0+i)*matA(nx,btotal(j,i))
        enddo
      enddo
      do i=1,nfi-nfi0
        k=fmonid(nfi0+i)-1
        j=nfi0+nb+i
        call poly_value(fmonid(nfi0+i),fmons(1,1:k,nfi0+i),fmons(2,1:k,nfi0+i),r0(1:nr,nx),matA(nx,j))
      enddo
    enddo
    write(702,'(i3,"*  ",i5,",",i5," in degree ",(i2),",",2x,3(1x,i6),2xes23.16)') nfi,iloop,np,degree,nb,nx,ny,error
    i0=1
    do i=1,nexit(0)
      if(nfi.eq.nexit(i)) then
        i0=0
        exit
      endif
    enddo
    if(i0.eq.0) exit
    !-------------------
    !do j=1,ny
    !  write(711,*) j,coefC(j)
    !enddo
    !  write(711,*) ""
 ! else
    !do j=1,ny
    !  write(713,*) j,coefC(j)
    !enddo
    !  write(713,*) ""
  else
    write(702,'(6x,i5,",",i5," in degree ",(i2),","2x,3(1x,i6),2xes23.16)') iloop,np,degree,nb,nx,ny,error
  endif
enddo
end subroutine cal_error

subroutine lsq(m,n,m0,n0,A,B,C,work)
implicit none
integer,intent(in) :: m,n,m0,n0
real(kind=8),intent(in) :: A(m0,n0),B(m0)
real(kind=8),intent(out) :: C(m0)
real(kind=8),intent(inout) :: work(2*m0*n0)
integer :: info,lwork
!call dgels('N',m,n,1,A,m0,B,m0,work,-1,info)
!lwork=int(work(1))
lwork=2*m*n
call dgels('N',m,n,1,A,m0,B,m0,work,lwork,info)
C(1:n)=B(1:n)
end subroutine lsq
